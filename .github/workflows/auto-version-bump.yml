name: Auto Bump Userscript Version

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  bump-and-tag:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Bump userscript version from changelog
        id: version
        run: |
          set -euo pipefail
          FILE="bytebytego-references.user.js"
          CHANGELOG="changelog.json"

          if [ ! -f "$CHANGELOG" ]; then
            echo "Missing changelog file at ${CHANGELOG}"
            exit 1
          fi

          node - <<'NODE'
          const fs = require('fs');

          const changelogPath = 'changelog.json';
          const scriptPath = 'bytebytego-references.user.js';

          if (!fs.existsSync(changelogPath)) {
            throw new Error('Missing changelog file at changelog.json');
          }

          let changelog;
          try {
            changelog = JSON.parse(fs.readFileSync(changelogPath, 'utf8'));
          } catch (err) {
            throw new Error(`Failed to parse changelog JSON: ${err.message}`);
          }

          if (!changelog || typeof changelog !== 'object' || !Array.isArray(changelog.entries)) {
            throw new Error('Missing changelog entries array');
          }

          let lastEntryVersion = null;
          let highestVersion = null;

          const parseSemver = (raw) => {
            if (typeof raw !== 'string') return null;
            const trimmed = raw.trim();
            if (!/^\d+(?:\.\d+){0,2}$/.test(trimmed)) return null;
            const parts = trimmed.split('.').map(p => parseInt(p, 10));
            while (parts.length < 3) parts.push(0);
            return { raw: trimmed, parts };
          };

          const compareParts = (a, b) => {
            for (let i = 0; i < Math.max(a.length, b.length); i++) {
              const av = a[i] ?? 0;
              const bv = b[i] ?? 0;
              if (av > bv) return 1;
              if (av < bv) return -1;
            }
            return 0;
          };

          for (const entry of changelog.entries) {
            if (!entry || !entry.version) continue;
            const rawVersion = String(entry.version).trim();
            lastEntryVersion = rawVersion;
            const parsed = parseSemver(rawVersion);
            if (!parsed) continue;
            if (!highestVersion || compareParts(parsed.parts, highestVersion.parts) > 0) {
              highestVersion = parsed;
            }
          }

          const releaseVersion = highestVersion?.raw || lastEntryVersion;
          if (!releaseVersion) {
            throw new Error('No version found in changelog');
          }

          if (!fs.existsSync(scriptPath)) {
            throw new Error(`Userscript not found at ${scriptPath}`);
          }

          const content = fs.readFileSync(scriptPath, 'utf8');
          const headerMatch = content.match(/@version\s+([0-9.]+)/);
          const scriptConstMatch = content.match(/const\s+SCRIPT_VERSION\s*=\s*['\"]([0-9.]+)['\"]/);

          if (!headerMatch) {
            throw new Error('Could not find @version in userscript header');
          }
          if (!scriptConstMatch) {
            throw new Error('Could not find SCRIPT_VERSION constant');
          }

          const headerVersion = headerMatch[1].trim();
          const constVersion = scriptConstMatch[1].trim();

          const outputs = [
            `new_version=${releaseVersion}`,
            `tag=v${releaseVersion}`
          ];

          const alreadyCurrent = headerVersion === releaseVersion && constVersion === releaseVersion;
          outputs.push(`changed=${alreadyCurrent ? 'false' : 'true'}`);

          if (alreadyCurrent) {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, outputs.join('\n') + '\n');
            console.log(`Versions already at ${releaseVersion}; no changes needed.`);
            process.exit(0);
          }

          const updatedHeader = content.replace(/(@version\s+)([0-9.]+)/, `$1${releaseVersion}`);
          const updatedScript = updatedHeader.replace(/(const\s+SCRIPT_VERSION\s*=\s*['"])([0-9.]+)(['"])/, `$1${releaseVersion}$3`);

          if (updatedScript === content) {
            throw new Error('Version replacements failed');
          }

          fs.writeFileSync(scriptPath, updatedScript, 'utf8');
          fs.appendFileSync(process.env.GITHUB_OUTPUT, outputs.join('\n') + '\n');
          console.log(`Updated versions: ${headerVersion}/${constVersion} -> ${releaseVersion}`);
          NODE

      - name: Ensure changelog contains new version
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = 'changelog.json';
          const newVersion = process.env.NEW_VERSION;

          if (!newVersion) {
            throw new Error('Missing NEW_VERSION environment variable');
          }
          if (!fs.existsSync(path)) {
            throw new Error(`Missing changelog file at ${path}`);
          }

          let parsed;
          try {
            parsed = JSON.parse(fs.readFileSync(path, 'utf8'));
          } catch (err) {
            throw new Error(`Failed to parse changelog JSON: ${err.message}`);
          }

          if (!parsed || typeof parsed !== 'object' || !Array.isArray(parsed.entries)) {
            throw new Error('Changelog must be an object with an "entries" array');
          }

          const exists = parsed.entries.some(entry => entry && entry.version === newVersion);
          if (exists) {
            console.log(`Changelog already contains version ${newVersion}`);
          } else {
            parsed.entries.push({
              version: newVersion,
              title: `ByteByteGo Reference Linker v${newVersion}`,
              changes: ['Automated version bump']
            });
            fs.writeFileSync(path, JSON.stringify(parsed, null, 2) + '\n', 'utf8');
            console.log(`Added changelog entry for version ${newVersion}`);
          }
          NODE
        env:
          NEW_VERSION: ${{ steps.version.outputs.new_version }}

      - name: Show git status
        if: steps.version.outputs.changed == 'true'
        run: git status --short

      - name: Configure git user
        if: steps.version.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit version bump
        if: steps.version.outputs.changed == 'true'
        run: |
          git add bytebytego-references.user.js
          git commit -m "chore: bump userscript version to v${{ steps.version.outputs.new_version }}"

      - name: Tag release version
        if: steps.version.outputs.changed == 'true'
        run: |
          git tag ${{ steps.version.outputs.tag }}

      - name: Push commit and tag
        if: steps.version.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push origin HEAD
          git push origin ${{ steps.version.outputs.tag }}